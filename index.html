<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insta-Clone Calculator</title>
    <!-- Use the Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: #6b7280;
        }

        /* Styles for the contenteditable div (our new input area) */
        #inputArea {
            -webkit-box-shadow: none;
            -moz-box-shadow: none;
            box-shadow: none;
            outline: none;
            resize: none;
            line-height: 1.5;
            padding: 1.5rem;
            color: #d1d5db; /* Light gray text */
            background-color: #111827; /* Dark background */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            caret-color: #fff; /* White cursor */
            overflow-y: auto; /* Enable scrolling */
        }
        /* Style for the syntax-highlighted spans */
        #inputArea .variable-new {
            color: #60a5fa; /* Blue */
        }
        #inputArea .variable-redefined {
            color: #f87171; /* Red */
        }
        #inputArea .comment {
            color: #facc15; /* Yellow */
        }
        #inputArea .operator {
            color: #a1a1aa; /* Gray-400 for operators like = */
        }
        #inputArea .keyword {
            color: #c084fc; /* Purple-400 for keywords like 'today' and 'to' */
        }
        #inputArea .unit {
            color: #2dd4bf; /* Teal-400 for units like 'usd', 'm', 'days' */
        }
        
        /* Custom styles for the toggle switch */
        .toggle-switch-container {
            display: inline-block;
            height: 24px;
            position: relative;
            width: 48px;
        }
        .toggle-switch-container input {
            display: none;
        }
        .toggle-slider {
            background-color: #4b5563; /* Gray background */
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            background-color: white;
            bottom: 4px;
            content: "";
            height: 16px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 16px;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #22c55e; /* Green background */
        }
        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased flex flex-col items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-4xl bg-gray-800 rounded-2xl shadow-2xl overflow-hidden flex flex-col md:flex-row h-[80vh]">
        <!-- Left Panel: Input Area -->
        <div class="flex-1 flex flex-col p-6 md:p-8">
            <div class="flex justify-between items-center mb-2">
                <h1 class="text-3xl font-bold text-white">Insta-Clone</h1>
                <button id="eraseButton" class="bg-red-600 text-white font-medium py-2 px-4 rounded-lg shadow-lg hover:bg-red-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50">Erase</button>
            </div>
            
            <div class="relative flex-1 min-h-0">
                <!-- The h-full class makes this div fill its newly constrained parent -->
                <div
                    id="inputArea"
                    contenteditable="true"
                    class="w-full h-full rounded-xl bg-gray-900 text-gray-200 font-mono text-lg transition-all duration-300 focus:ring-4 focus:ring-blue-500/50"
                ></div>
            </div>
        </div>
        <!-- Right Panel: Output Area -->
        <div class="flex-1 flex flex-col p-6 md:p-8 border-t-2 md:border-t-0 md:border-l-2 border-gray-700 bg-gray-700/30">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-white">Results</h2>
                <div class="flex items-center space-x-2">
                    <label class="text-gray-400">No sleep mode</label>
                    <label class="toggle-switch-container">
                        <input type="checkbox" id="noSleepToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <div id="outputArea" class="relative flex-1 bg-gray-900 rounded-xl p-6 overflow-y-auto text-gray-200 font-mono text-lg leading-relaxed">
                <div class="text-gray-400">Your results will appear here in real-time.</div>
            </div>
        </div>
    </div>

    <!-- Saved Calculations Section, now at the very bottom -->
    <div class="w-full max-w-4xl mt-8 p-6 md:p-8 bg-gray-800 rounded-2xl shadow-2xl">
        <h3 class="text-lg font-semibold text-white mb-2">Saved Calculations (3 slots)</h3>
        <div id="save-buttons" class="grid grid-cols-3 gap-2">
            <button id="save-1" class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200">Save 1</button>
            <button id="save-2" class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200">Save 2</button>
            <button id="save-3" class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200">Save 3</button>
        </div>
        <div id="load-buttons" class="grid grid-cols-3 gap-2 mt-2">
            <button id="load-1" class="bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">Load 1</button>
            <button id="load-2" class="bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">Load 2</button>
            <button id="load-3" class="bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">Load 3</button>
        </div>
    </div>

    <!-- Confirmation Modal (hidden by default) -->
    <div id="confirm-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-70">
        <div class="bg-gray-800 rounded-xl p-6 w-96 shadow-2xl border border-gray-700">
            <h4 class="text-xl font-bold mb-4">Overwrite Calculation?</h4>
            <p id="confirm-message" class="text-gray-400 mb-6">This slot already has a saved calculation. Do you want to replace it?</p>
            <div class="flex justify-end gap-4">
                <button id="confirm-cancel" class="bg-gray-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-gray-700">Cancel</button>
                <button id="confirm-ok" class="bg-red-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-red-700">Overwrite</button>
            </div>
        </div>
    </div>

    <!-- Message Box (hidden by default) -->
    <div id="message-box" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 bg-gray-800 text-white rounded-lg shadow-lg z-50 hidden opacity-0 transition-opacity duration-300">
        <p id="message-text"></p>
    </div>

    <script>
        // --- Core Application Logic ---
        
        // DOM element references
        const inputArea = document.getElementById('inputArea');
        const outputArea = document.getElementById('outputArea');
        const eraseButton = document.getElementById('eraseButton');

        // References for the new save/load functionality
        const saveButtons = document.querySelectorAll('#save-buttons button');
        const loadButtons = document.querySelectorAll('#load-buttons button');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmOk = document.getElementById('confirm-ok');
        const confirmCancel = document.getElementById('confirm-cancel');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');

        // References for the new no-sleep mode
        const noSleepToggle = document.getElementById('noSleepToggle');
        let wakeLock = null; // A sentinel to hold the wake lock
        
        // Global object to store user-defined variables
        let variables = {};
        
        // Hardcoded conversion rates for demonstration purposes
        const conversionRates = {
            usd: { eur: 0.92, gbp: 0.78 },
            eur: { usd: 1.09, gbp: 0.85 },
            gbp: { usd: 1.28, eur: 1.17 },
            
            // Length units
            m: { ft: 3.28084, cm: 100 },
            ft: { m: 0.3048, cm: 30.48 },
            cm: { m: 0.01, ft: 0.0328084 },

            // Mass units
            kg: { lb: 2.20462 },
            lb: { kg: 0.453592 },
        };

        // Definitions for syntax highlighting
        const specialWords = {
            'today': 'keyword', 'to': 'keyword',
            'usd': 'unit', 'eur': 'unit', 'gbp': 'unit',
            'm': 'unit', 'ft': 'unit', 'cm': 'unit',
            'kg': 'unit', 'lb': 'unit',
            'days': 'unit', 'day': 'unit', 'weeks': 'unit', 'week': 'unit',
            'months': 'unit', 'month': 'unit', 'years': 'unit', 'year': 'unit',
            'hours': 'unit', 'hour': 'unit', 'minutes': 'unit', 'minute': 'unit',
        };
        
        // --- Helper Functions ---

        /**
         * Shows a temporary message box with a given text.
         * @param {string} text The message to display.
         */
        const showMessage = (text) => {
            messageText.textContent = text;
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.remove('opacity-0');
            }, 10);
            setTimeout(() => {
                messageBox.classList.add('opacity-0');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 300);
            }, 3000);
        };

        /**
         * A safer, custom function to perform calculations, including percentages and unit conversions.
         * @param {string} expression The mathematical expression to calculate.
         * @returns {number|string|undefined} The result of the calculation.
         */
        const calculate = (expression) => {
            // Step 1: Check for unit conversion pattern
            // Regex to match "value unit to unit"
            const conversionMatch = expression.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z]+)\s*to\s*([a-zA-Z]+)$/);
            if (conversionMatch) {
                const value = parseFloat(conversionMatch[1]);
                const fromUnit = conversionMatch[2].toLowerCase();
                const toUnit = conversionMatch[3].toLowerCase();

                // Check if the conversion is supported
                if (conversionRates[fromUnit] && conversionRates[fromUnit][toUnit]) {
                    const rate = conversionRates[fromUnit][toUnit];
                    return value * rate;
                } else {
                    return `Error: Unsupported conversion from '${fromUnit}' to '${toUnit}'.`;
                }
            }

            // Step 2: If no conversion, handle percentage calculations
            const percentageRegex = /((?:\d+(?:\.\d+)?))\s*([+\-*/])\s*((?:\d+(?:\.\d+)?))\s*%/g;
            let preprocessedExpression = expression;
            let match;

            while ((match = percentageRegex.exec(preprocessedExpression)) !== null) {
                const baseValue = parseFloat(match[1]);
                const operator = match[2];
                const percentageValue = parseFloat(match[3]);
                
                let replacement;
                if (operator === '+' || operator === '-') {
                    replacement = `${baseValue} ${operator} (${baseValue} * ${percentageValue} / 100)`;
                } else {
                    replacement = `${baseValue} ${operator} (${percentageValue} / 100)`;
                }

                preprocessedExpression =
                    preprocessedExpression.substring(0, match.index) +
                    replacement +
                    preprocessedExpression.substring(match.index + match[0].length);

                percentageRegex.lastIndex = 0;
            }

            // Step 3: Evaluate the final expression
            try {
                const result = new Function(`return ${preprocessedExpression}`)();
                if (typeof result === 'number' && !isNaN(result)) {
                    return result;
                }
                return undefined;
            } catch (error) {
                return undefined;
            }
        };

        /**
         * Replaces user-defined variables in an expression with their stored values.
         * @param {string} expression The mathematical expression string.
         * @returns {string} The expression with variables replaced.
         */
        const replaceVariables = (expression) => {
            // Sort keys by length in descending order to avoid issues with variable names that are substrings of others (e.g., `a` vs `area`).
            const sortedKeys = Object.keys(variables).sort((a, b) => b.length - a.length);

            let replacedExpression = expression;
            for (const key of sortedKeys) {
                // Use a regular expression with a word boundary (\b) to ensure we're replacing the full variable name
                const regex = new RegExp(`\\b${key}\\b`, 'g');
                replacedExpression = replacedExpression.replace(regex, variables[key]);
            }
            return replacedExpression;
        };

        /**
         * Parses and evaluates a single line of input.
         * @param {string} line The single line of text to evaluate.
         * @returns {string|null} The calculated result as a string, or null if the line is a variable assignment.
         */
        const evaluateLine = (line) => {
            line = line.trim();
            if (!line) return null; // Skip empty lines

            // First, check for variable assignment (e.g., `variable = value`)
            const assignmentMatch = line.match(/^([a-zA-Z_]\w*)\s*=\s*(.*)$/);
            if (assignmentMatch) {
                const varName = assignmentMatch[1];
                const expression = assignmentMatch[2];
                try {
                    // Replace variables in the expression before calculating
                    const sanitizedExpression = replaceVariables(expression);
                    const result = calculate(sanitizedExpression);
                    variables[varName] = result; // Store the result in the variables object
                    return null; // Return null for assignments, as there's no output to display
                } catch (e) {
                    return `Error: Invalid assignment for '${varName}'.`;
                }
            }

            // Next, check for date calculation pattern (e.g., "today + 90 days" or "today + y days")
            const dateMatch = line.match(/^today\s*([+\-])\s*([a-zA-Z_]\w*|\d+)\s*(days?|weeks?|months?|years?)$/i);
            if (dateMatch) {
                const operator = dateMatch[1];
                const valuePart = dateMatch[2];
                const unit = dateMatch[3].toLowerCase();
                let value;
                
                if (isNaN(valuePart)) {
                    // It's a variable name, look it up
                    if (variables[valuePart] !== undefined && !isNaN(variables[valuePart])) {
                        value = parseInt(variables[valuePart], 10);
                    } else {
                        return `Error: Variable '${valuePart}' is not a valid number.`;
                    }
                } else {
                    // It's a number
                    value = parseInt(valuePart, 10);
                }
                
                const today = new Date();
                
                if (operator === '+') {
                    if (unit.startsWith('day')) today.setDate(today.getDate() + value);
                    else if (unit.startsWith('week')) today.setDate(today.getDate() + (value * 7));
                    else if (unit.startsWith('month')) today.setMonth(today.getMonth() + value);
                    else if (unit.startsWith('year')) today.setFullYear(today.getFullYear() + value);
                } else if (operator === '-') {
                    if (unit.startsWith('day')) today.setDate(today.getDate() - value);
                    else if (unit.startsWith('week')) today.setDate(today.getDate() - (value * 7));
                    else if (unit.startsWith('month')) today.setMonth(today.getMonth() - value);
                    else if (unit.startsWith('year')) today.setFullYear(today.getFullYear() - value);
                }
                
                return today.toDateString();
            }

            // New: Check for time calculation pattern (e.g., "14:00 + 4 hours")
            const timeMatch = line.match(/^(\d{1,2}:\d{2})\s*([+\-])\s*(\d+)\s*(hours?|minutes?)$/i);
            if (timeMatch) {
                const timeString = timeMatch[1];
                const operator = timeMatch[2];
                const value = parseInt(timeMatch[3], 10);
                const unit = timeMatch[4].toLowerCase();

                const [hours, minutes] = timeString.split(':').map(Number);
                const date = new Date();
                date.setHours(hours, minutes, 0, 0);

                if (operator === '+') {
                    if (unit.startsWith('hour')) date.setHours(date.getHours() + value);
                    else if (unit.startsWith('minute')) date.setMinutes(date.getMinutes() + value);
                } else if (operator === '-') {
                    if (unit.startsWith('hour')) date.setHours(date.getHours() - value);
                    else if (unit.startsWith('minute')) date.setMinutes(date.getMinutes() - value);
                }

                // Format the time as HH:MM
                const newHours = String(date.getHours()).padStart(2, '0');
                const newMinutes = String(date.getMinutes()).padStart(2, '0');
                return `${newHours}:${newMinutes}`;
            }

            // If it's not an assignment or a date calculation, try to evaluate it as a direct expression
            try {
                const sanitizedExpression = replaceVariables(line);
                const result = calculate(sanitizedExpression);
                if (result !== undefined) {
                    return result;
                }
            } catch (e) {
                // If it fails, it might be an invalid expression or a comment
                return null;
            }

            return null; // For lines that don't produce a result (e.g., comments)
        };

        /**
         * Updates the output area and calls the highlighting function.
         */
        const processInput = () => {
            // First, re-highlight the input area
            highlightInput();

            // Then, process the content for the output area
            variables = {};
            const lines = inputArea.textContent.split('\n');
            let outputHTML = '';
            
            const assignmentRegex = /^([a-zA-Z_]\w*)\s*=.*$/;
            
            lines.forEach((line) => {
                const trimmedLine = line.trim();
                
                if (!trimmedLine) {
                    outputHTML += `<div class="h-6"></div>`;
                    return;
                }

                let codePart = line;
                let commentPart = null;
                const commentIndex = line.indexOf('//');
                if (commentIndex !== -1) {
                    codePart = line.substring(0, commentIndex);
                    commentPart = line.substring(commentIndex);
                }

                const trimmedCodePart = codePart.trim();
                let result = null;
                let isRedefined = false;

                if (trimmedCodePart) {
                    const assignmentMatch = trimmedCodePart.match(assignmentRegex);
                    if (assignmentMatch) {
                        const varName = assignmentMatch[1];
                        if (variables.hasOwnProperty(varName)) {
                            isRedefined = true;
                        }
                    }
                    result = evaluateLine(trimmedCodePart);
                }

                // Now build the output HTML based on the parts
                if (result !== null && result !== undefined) {
                    // It's a line with a result. The result number is now a bright green.
                    outputHTML += `<div class="flex items-start">
                                      <span class="mr-4 text-blue-400 font-bold">></span>
                                      <span class="flex-1">${trimmedCodePart}</span>
                                      <span class="flex-1 text-right text-gray-400">= <span class="text-green-400">${result}</span></span>`;
                    if (commentPart) {
                        outputHTML += `<span class="text-yellow-400 ml-4">${commentPart}</span>`;
                    }
                    outputHTML += `</div>`;
                } else if (assignmentRegex.test(trimmedCodePart)) {
                    // It's a variable assignment
                    const outputClass = isRedefined ? 'text-red-400' : 'text-blue-400';
                    outputHTML += `<div class="flex items-start">
                                      <span class="mr-4 ${outputClass} font-bold">></span>
                                      <span class="flex-1 ${outputClass}">${trimmedCodePart}</span>`;
                    if (commentPart) {
                        outputHTML += `<span class="text-yellow-400 ml-4">${commentPart}</span>`;
                    }
                    outputHTML += `</div>`;
                } else if (commentPart) {
                    // It's a pure comment line
                    outputHTML += `<div class="flex items-start">
                                      <span class="mr-4 text-yellow-400 font-bold">//</span>
                                      <span class="flex-1 text-yellow-400">${commentPart.substring(2)}</span>
                                  </div>`;
                } else {
                     // It's a non-comment, non-evaluative line
                     outputHTML += `<div class="flex items-start">
                                      <span class="mr-4 text-gray-500 font-bold">></span>
                                      <span class="flex-1 text-gray-500">${line}</span>
                                  </div>`;
                }
            });
            
            outputArea.innerHTML = outputHTML || '<div class="text-gray-400">Your results will appear here in real-time.</div>';
        };

        /**
         * Handles syntax highlighting for the input area using a token-based approach
         * and preserves the cursor position correctly.
         */
        const highlightInput = () => {
            // Step 1: Save the current cursor position.
            let savedOffset = 0;
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(inputArea);
                preCaretRange.setEnd(range.startContainer, range.startOffset);
                savedOffset = preCaretRange.toString().length;
            }
            
            // Step 2: Generate the new HTML with syntax highlighting.
            const content = inputArea.textContent;
            const definedVariables = new Set();
            const lines = content.split('\n');
            const assignmentRegex = /^([a-zA-Z_]\w*)\s*=/;
            const escapeHtml = (text) => text.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');

            const highlightedLines = lines.map(line => {
                const commentIndex = line.indexOf('//');
                const codePart = commentIndex !== -1 ? line.substring(0, commentIndex) : line;
                const commentPart = commentIndex !== -1 ? `<span class="comment">${escapeHtml(line.substring(commentIndex))}</span>` : '';

                let processedCode = '';
                const assignmentMatch = codePart.trim().match(assignmentRegex);
                const tokens = codePart.split(/(\b[a-zA-Z_]\w*\b|=|\s+)/).filter(Boolean);

                if (assignmentMatch) {
                    const varName = assignmentMatch[1];
                    const varClass = definedVariables.has(varName) ? 'variable-redefined' : 'variable-new';
                    definedVariables.add(varName);
                    let isVarFound = false;

                    tokens.forEach(token => {
                        if (!isVarFound && token === varName) {
                            processedCode += `<span class="${varClass}">${escapeHtml(token)}</span>`;
                            isVarFound = true;
                        } else if (specialWords[token]) {
                            processedCode += `<span class="${specialWords[token]}">${escapeHtml(token)}</span>`;
                        } else if (token === '=') {
                            processedCode += `<span class="operator">${token}</span>`;
                        } else {
                            processedCode += escapeHtml(token);
                        }
                    });
                } else {
                    tokens.forEach(token => {
                        if (specialWords[token]) {
                            processedCode += `<span class="${specialWords[token]}">${escapeHtml(token)}</span>`;
                        } else if (token === '=') {
                            processedCode += `<span class="operator">${token}</span>`;
                        } else {
                            processedCode += escapeHtml(token);
                        }
                    });
                }
                return processedCode + commentPart;
            });
            
            const highlightedHtml = highlightedLines.join('\n');
            inputArea.innerHTML = highlightedHtml;

            // Step 3: Restore the cursor.
            let charCount = 0;
            const newRange = document.createRange();
            const treeWalker = document.createTreeWalker(inputArea, NodeFilter.SHOW_TEXT);
            let node;

            while (node = treeWalker.nextNode()) {
                const nextCharCount = charCount + node.length;
                if (nextCharCount >= savedOffset) {
                    newRange.setStart(node, savedOffset - charCount);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                    return;
                }
                charCount = nextCharCount;
            }
             // Fallback for when the cursor is at the very end
            newRange.selectNodeContents(inputArea);
            newRange.collapse(false);
            selection.removeAllRanges();
            selection.addRange(newRange);
        };


        // --- Wake Lock Functionality ---

        /**
         * Attempts to request a screen wake lock.
         */
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                if (wakeLock !== null) {
                    return;
                }
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake lock was released');
                        wakeLock = null; 
                        if (noSleepToggle.checked) {
                            noSleepToggle.checked = false;
                            showMessage('Screen wake lock was released.');
                        }
                    });
                    showMessage('Screen wake lock is active.');
                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                    if (err.name === 'NotAllowedError') {
                        showMessage('Failed to enable "No sleep mode". This feature may be blocked by your browser\'s security policy.');
                    } else {
                        showMessage(`Error: Could not activate "No sleep mode". Reason: ${err.message}`);
                    }
                    noSleepToggle.checked = false;
                }
            } else {
                 showMessage('Wake Lock API not supported in this browser.');
                 noSleepToggle.checked = false;
            }
        };

        /**
         * Releases the screen wake lock.
         */
        const releaseWakeLock = () => {
            if (wakeLock !== null) {
                wakeLock.release().then(() => {
                    wakeLock = null;
                    showMessage('Screen wake lock is released.');
                });
            }
        };

        // --- Event Listeners ---

        // Event listener for real-time processing as the user types
        inputArea.addEventListener('input', processInput);
        
        // -- THIS IS THE FIX --
        // A robust listener to correctly handle the 'Enter' key.
        inputArea.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default (and messy) browser behavior

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                range.deleteContents(); // Clear selection if any

                const newlineNode = document.createTextNode('\n');
                range.insertNode(newlineNode);

                // Move cursor to after the new line
                range.setStartAfter(newlineNode);
                range.collapse(true);

                selection.removeAllRanges();
                selection.addRange(range);

                // The 'input' event will now fire automatically due to the DOM change,
                // which correctly triggers processInput().
            }
        });

        // Event listener for the erase button
        eraseButton.addEventListener('click', () => {
            inputArea.textContent = '';
            processInput();
            showMessage('Calculator cleared!');
        });
        
        // Event listeners for save buttons
        saveButtons.forEach(button => {
            button.addEventListener('click', () => {
                const slot = button.id.split('-')[1];
                const key = `instacalc_slot_${slot}`;
                const currentValue = inputArea.textContent;

                if (localStorage.getItem(key)) {
                    confirmModal.classList.remove('hidden');
                    confirmModal.classList.add('flex');
                    
                    confirmOk.onclick = () => {
                        localStorage.setItem(key, currentValue);
                        confirmModal.classList.add('hidden');
                        confirmModal.classList.remove('flex');
                        showMessage(`Calculation saved to slot ${slot}!`);
                    };
                    confirmCancel.onclick = () => {
                        confirmModal.classList.add('hidden');
                        confirmModal.classList.remove('flex');
                    };
                } else {
                    localStorage.setItem(key, currentValue);
                    showMessage(`Calculation saved to slot ${slot}!`);
                }
            });
        });

        // Event listeners for load buttons
        loadButtons.forEach(button => {
            button.addEventListener('click', () => {
                const slot = button.id.split('-')[1];
                const key = `instacalc_slot_${slot}`;
                const savedValue = localStorage.getItem(key);

                if (savedValue) {
                    inputArea.textContent = savedValue;
                    processInput();
                    showMessage(`Calculation loaded from slot ${slot}!`);
                } else {
                    showMessage(`Slot ${slot} is empty.`);
                }
            });
        });

        // Event listener for the new no-sleep toggle
        noSleepToggle.addEventListener('change', () => {
            if (noSleepToggle.checked) {
                requestWakeLock();
            } else {
                releaseWakeLock();
            }
        });

        // Re-request wake lock if the page becomes visible and the toggle is still on
        document.addEventListener('visibilitychange', () => {
            if (wakeLock !== null && document.visibilityState === 'visible' && noSleepToggle.checked) {
                requestWakeLock();
            }
        });

        // Initial processing on page load
        window.addEventListener('DOMContentLoaded', () => {
             // Set a default value and trigger the initial calculation
            inputArea.textContent = `// Welcome to Insta-Clone!
// Now supports date, time, percentage, and unit calculations.

// Date calculations with variables
y = 20
today + y days

// Expanded date calculations (weeks, months, years)
today + 3 weeks
today - 6 months
today + 2 years

// Time calculations
14:00 + 4 hours

// This is an example of a commented line
flight = 33 // per person
flight = 50 // Re-assigning the value

// Use the buttons at the bottom of the page to save and load your work.
// Use the new "No sleep mode" toggle to prevent your screen from sleeping.

// Percentage calculations
340 + 15%

// Unit conversions
23 usd to eur
100 m to ft

// You can use conversions with variables too
distance_m = 50
distance_m to cm

// The result of the last line will be displayed
25 gbp to usd`;
            processInput();
        });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insta-Clone Calculator</title>
    <!-- Use the Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: #6b7280;
        }

        /* Styles for the contenteditable div (our new input area) */
        #inputArea {
            -webkit-box-shadow: none;
            -moz-box-shadow: none;
            box-shadow: none;
            outline: none;
            resize: none;
            line-height: 1.5;
            padding: 1.5rem;
            color: #d1d5db; /* Light gray text */
            background-color: #111827; /* Dark background */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            caret-color: #fff; /* White cursor */
            overflow-y: auto; /* Enable scrolling */
        }
        /* Style for the syntax-highlighted spans */
        #inputArea .variable-new, .output-highlight .variable-new {
            color: #60a5fa; /* Blue */
        }
        #inputArea .variable-redefined, .output-highlight .variable-redefined {
            color: #f87171; /* Red */
        }
        #inputArea .variable-used, .output-highlight .variable-used {
            color: #fb923c; /* Orange-400 */
        }
        #inputArea .comment, .output-highlight .comment {
            color: #facc15; /* Yellow */
        }
        #inputArea .operator, .output-highlight .operator {
            color: #a1a1aa; /* Gray-400 for operators like = */
        }
        #inputArea .keyword, .output-highlight .keyword {
            color: #c084fc; /* Purple-400 for keywords like 'today' and 'to' */
        }
        #inputArea .unit, .output-highlight .unit {
            color: #2dd4bf; /* Teal-400 for units like 'usd', 'm', 'days' */
        }
        
        /* Styles for Autocomplete Popup */
        #autocomplete-popup {
            position: absolute;
            z-index: 100;
            background-color: #1f2937; /* gray-800 */
            border: 1px solid #374151; /* gray-700 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            max-height: 200px;
            overflow-y: auto;
            min-width: 150px;
        }
        .autocomplete-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #d1d5db; /* gray-300 */
        }
        .autocomplete-item:hover, .autocomplete-item.selected {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
        
        /* Custom styles for the toggle switch */
        .toggle-switch-container { display: inline-block; height: 24px; position: relative; width: 48px; }
        .toggle-switch-container input { display: none; }
        .toggle-slider { background-color: #4b5563; bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 34px; }
        .toggle-slider:before { background-color: white; bottom: 4px; content: ""; height: 16px; left: 4px; position: absolute; transition: .4s; width: 16px; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: #22c55e; }
        input:checked + .toggle-slider:before { transform: translateX(24px); }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased flex flex-col items-center h-screen p-4">
    <div class="w-full max-w-4xl bg-gray-800 rounded-2xl shadow-2xl overflow-hidden flex flex-col md:flex-row flex-1 min-h-0">
        <!-- Left Panel: Input Area -->
        <div class="flex-1 flex flex-col p-6 md:p-8">
            <!-- --- THIS IS THE MODIFIED HEADER FOR THE LEFT PANEL --- -->
            <div class="flex justify-between items-center mb-2 h-12">
                <h2 class="text-2xl font-bold text-white">Insta-Clone</h2>
                <button id="eraseButton" class="bg-red-600 text-white font-medium py-2 px-4 rounded-lg shadow-lg hover:bg-red-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50">Erase</button>
            </div>
            
            <div class="relative flex-1 min-h-0">
                <div id="inputArea" contenteditable="true" class="w-full h-full rounded-xl bg-gray-900 text-gray-200 font-mono text-lg transition-all duration-300 focus:ring-4 focus:ring-blue-500/50"></div>
                <div id="autocomplete-popup" class="hidden"></div>
            </div>
        </div>
        <!-- Right Panel: Output Area -->
        <div class="flex-1 flex flex-col p-6 md:p-8 border-t-2 md:border-t-0 md:border-l-2 border-gray-700 bg-gray-700/30">
            <!-- --- THIS IS THE MODIFIED HEADER FOR THE RIGHT PANEL --- -->
            <div class="flex justify-between items-center mb-2 h-12">
                <h2 class="text-2xl font-bold text-white">Results</h2>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <label class="text-gray-400 text-sm">No sleep</label>
                        <label class="toggle-switch-container">
                            <input type="checkbox" id="noSleepToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <label class="text-gray-400 text-sm">Round</label>
                        <label class="toggle-switch-container">
                            <input type="checkbox" id="roundingToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div id="outputArea" class="relative flex-1 bg-gray-900 rounded-xl p-6 overflow-y-auto text-gray-200 font-mono text-lg leading-relaxed">
                <div class="text-gray-400">Your results will appear here in real-time.</div>
            </div>
        </div>
    </div>

    <!-- Saved Calculations Section -->
    <div class="w-full max-w-4xl mt-4 p-6 md:p-8 bg-gray-800 rounded-2xl shadow-2xl">
        <h3 class="text-lg font-semibold text-white mb-2">Saved Calculations (3 slots)</h3>
        <div id="save-buttons" class="grid grid-cols-3 gap-2">
            <button class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-green-700">Save 1</button>
            <button class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-green-700">Save 2</button>
            <button class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-green-700">Save 3</button>
        </div>
        <div id="load-buttons" class="grid grid-cols-3 gap-2 mt-2">
            <button class="bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700">Load 1</button>
            <button class="bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700">Load 2</button>
            <button class="bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700">Load 3</button>
        </div>
    </div>

    <!-- Confirmation & Message Modals -->
    <div id="confirm-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-70">
        <div class="bg-gray-800 rounded-xl p-6 w-96 shadow-2xl border border-gray-700">
            <h4 class="text-xl font-bold mb-4">Overwrite Calculation?</h4>
            <p id="confirm-message" class="text-gray-400 mb-6">This slot already has a saved calculation. Do you want to replace it?</p>
            <div class="flex justify-end gap-4">
                <button id="confirm-cancel" class="bg-gray-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-gray-700">Cancel</button>
                <button id="confirm-ok" class="bg-red-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-red-700">Overwrite</button>
            </div>
        </div>
    </div>
    <div id="message-box" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 bg-gray-800 text-white rounded-lg shadow-lg z-50 hidden opacity-0 transition-opacity duration-300"><p id="message-text"></p></div>

    <script>
        // --- Core Application Logic ---
        
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        const inputArea = $('#inputArea');
        const outputArea = $('#outputArea');
        const eraseButton = $('#eraseButton');
        const autocompletePopup = $('#autocomplete-popup');
        const confirmModal = $('#confirm-modal');
        const messageBox = $('#message-box');
        const roundingToggle = $('#roundingToggle');
        const noSleepToggle = $('#noSleepToggle');

        let variables = {};
        let wakeLock = null;
        let autocompleteState = { active: false, suggestions: [], selectedIndex: -1, wordStartIndex: -1 };
        
        const conversionRates = {
            usd: { eur: 0.92, gbp: 0.78 }, eur: { usd: 1.09, gbp: 0.85 }, gbp: { usd: 1.28, eur: 1.17 },
            m: { ft: 3.28084, cm: 100 }, ft: { m: 0.3048, cm: 30.48 }, cm: { m: 0.01, ft: 0.0328084 },
            kg: { lb: 2.20462 }, lb: { kg: 0.453592 },
        };

        const specialWords = {
            'today': 'keyword', 'to': 'keyword', 'usd': 'unit', 'eur': 'unit', 'gbp': 'unit',
            'm': 'unit', 'ft': 'unit', 'cm': 'unit', 'kg': 'unit', 'lb': 'unit',
            'days': 'unit', 'day': 'unit', 'weeks': 'unit', 'week': 'unit', 'months': 'unit', 'month': 'unit',
            'years': 'unit', 'year': 'unit', 'hours': 'unit', 'hour': 'unit', 'minutes': 'unit', 'minute': 'unit',
        };

        const getAutocompleteKeywords = (textContent) => {
            const orderedVars = [];
            textContent.split('\n').forEach(line => {
                const match = line.trim().match(/^([a-zA-Z_]\w*)\s*=/);
                if (match) {
                    const varName = match[1];
                    const existingIndex = orderedVars.indexOf(varName);
                    if (existingIndex > -1) orderedVars.splice(existingIndex, 1);
                    orderedVars.push(varName);
                }
            });
            const newestVarsFirst = orderedVars.reverse();
            const specialKeywordsList = Object.keys(specialWords);
            return [...newestVarsFirst, ...specialKeywordsList.filter(k => !orderedVars.includes(k))];
        };
        
        // --- Helper Functions ---

        const showMessage = (text) => {
            $('#message-text').textContent = text;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.remove('opacity-0'), 10);
            setTimeout(() => {
                messageBox.classList.add('opacity-0');
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, 3000);
        };

        const calculate = (expression) => {
            const conversionMatch = expression.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z]+)\s*to\s*([a-zA-Z]+)$/);
            if (conversionMatch) {
                const [, value, fromUnit, toUnit] = conversionMatch.map(s => s.toLowerCase());
                if (conversionRates[fromUnit]?.[toUnit]) {
                    return parseFloat(value) * conversionRates[fromUnit][toUnit];
                }
                return `Error: Unsupported conversion.`;
            }
            expression = expression.replace(/(\d+(?:\.\d+)?)\s*([+\-*/])\s*(\d+(?:\.\d+)?)%/g, (match, base, op, perc) => {
                const p = parseFloat(perc) / 100;
                return op === '+' || op === '-' ? `${base} ${op} (${base} * ${p})` : `${base} ${op} ${p}`;
            });
            try {
                const result = new Function(`return ${expression}`)();
                return (typeof result === 'number' && !isNaN(result)) ? result : undefined;
            } catch { return undefined; }
        };

        const replaceVariables = (expression) => {
            return Object.keys(variables)
                .sort((a, b) => b.length - a.length)
                .reduce((expr, key) => expr.replace(new RegExp(`\\b${key}\\b`, 'g'), variables[key]), expression);
        };
        
        const evaluateLine = (line) => {
            line = line.trim();
            if (!line) return null;

            const assignmentMatch = line.match(/^([a-zA-Z_]\w*)\s*=\s*(.*)$/);
            if (assignmentMatch) {
                const [, varName, expression] = assignmentMatch;
                variables[varName] = calculate(replaceVariables(expression));
                return null;
            }
            
            const dateMatch = line.match(/^today\s*([+\-])\s*([a-zA-Z_]\w*|\d+)\s*(days?|weeks?|months?|years?)$/i);
            if (dateMatch) {
                const [, operator, valuePart, unit] = dateMatch;
                const value = isNaN(valuePart) ? parseInt(variables[valuePart], 10) : parseInt(valuePart, 10);
                if (isNaN(value)) return `Error: Invalid number.`;

                const today = new Date();
                const mult = operator === '+' ? 1 : -1;
                const u = unit.toLowerCase();

                if (u.startsWith('day')) today.setDate(today.getDate() + value * mult);
                else if (u.startsWith('week')) today.setDate(today.getDate() + value * 7 * mult);
                else if (u.startsWith('month')) today.setMonth(today.getMonth() + value * mult);
                else if (u.startsWith('year')) today.setFullYear(today.getFullYear() + value * mult);
                return today.toDateString();
            }

            return calculate(replaceVariables(line));
        };
        
        const formatResult = (result) => {
            if (typeof result === 'number' && roundingToggle.checked) {
                if (!Number.isInteger(result)) {
                    return result.toFixed(2);
                }
            }
            return result;
        };

        // --- Central Highlighting Engine ---
        const highlightText = (line, definedVars) => {
            const escapeHtml = (text) => text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const commentIndex = line.indexOf('//');
            const codePart = commentIndex !== -1 ? line.substring(0, commentIndex) : line;
            const commentPart = commentIndex !== -1 ? `<span class="comment">${escapeHtml(line.substring(commentIndex))}</span>` : '';
            
            const assignmentMatch = codePart.trim().match(/^([a-zA-Z_]\w*)\s*=/);
            const varNameOnLine = assignmentMatch ? assignmentMatch[1] : null;

            const tokens = codePart.split(/(\b[a-zA-Z_]\w*\b|=|\s+)/).filter(Boolean);
            const processedCode = tokens.map(token => {
                if (token.trim() === '') return token;
                if (token === '=') return `<span class="operator">${token}</span>`;
                if (specialWords[token]) return `<span class="${specialWords[token]}">${escapeHtml(token)}</span>`;
                
                if (token === varNameOnLine) {
                    return `<span class="${definedVars.has(token) ? 'variable-redefined' : 'variable-new'}">${escapeHtml(token)}</span>`;
                }
                if (definedVars.has(token)) {
                    return `<span class="variable-used">${escapeHtml(token)}</span>`;
                }
                return escapeHtml(token);
            }).join('');

            return processedCode + commentPart;
        };

        // --- Main Processing and UI Updates ---
        const processInput = () => {
            highlightInput();
            
            variables = {};
            const lines = inputArea.textContent.split('\n');
            let outputHTML = '';
            
            lines.forEach((line) => {
                let currentLineHTML = '';
                const trimmedLine = line.trim();
                
                if (!trimmedLine) {
                    currentLineHTML = `<div class="h-6"></div>`;
                } else {
                    const lineVars = new Set(Object.keys(variables));
                    const highlightedLine = highlightText(line, lineVars);
                    const result = evaluateLine(line);
                    
                    if (result !== null && result !== undefined) {
                        const formattedResult = formatResult(result);
                        currentLineHTML = `<div class="flex items-start output-highlight">
                            <span class="mr-4 text-blue-400 font-bold">></span>
                            <span class="flex-1">${highlightedLine}</span>
                            <span class="flex-1 text-right text-gray-400">= <span class="text-green-400">${formattedResult}</span></span>
                        </div>`;
                    } else {
                         currentLineHTML = `<div class="flex items-start output-highlight">
                            <span class="mr-4 text-gray-400 font-bold">></span>
                            <span class="flex-1">${highlightedLine}</span>
                        </div>`;
                    }
                }
                outputHTML += currentLineHTML;
            });
            
            outputArea.innerHTML = outputHTML || '<div class="text-gray-400">Your results will appear here in real-time.</div>';
        };

        const highlightInput = () => {
            const selection = window.getSelection();
            const savedOffset = (selection.rangeCount > 0) ? (() => {
                const range = selection.getRangeAt(0).cloneRange();
                range.selectNodeContents(inputArea);
                range.setEnd(selection.getRangeAt(0).startContainer, selection.getRangeAt(0).startOffset);
                return range.toString().length;
            })() : 0;
            
            const definedVariables = new Set();
            const lines = inputArea.textContent.split('\n');
            const highlightedLines = lines.map(line => {
                const highlighted = highlightText(line, definedVariables);
                const assignmentMatch = line.trim().match(/^([a-zA-Z_]\w*)\s*=/);
                if (assignmentMatch) definedVariables.add(assignmentMatch[1]);
                return highlighted;
            });

            inputArea.innerHTML = highlightedLines.join('\n');
            
            let charCount = 0;
            const newRange = document.createRange();
            const treeWalker = document.createTreeWalker(inputArea, NodeFilter.SHOW_TEXT);
            let node;
            while (node = treeWalker.nextNode()) {
                if (charCount + node.length >= savedOffset) {
                    newRange.setStart(node, savedOffset - charCount);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                    return;
                }
                charCount += node.length;
            }
            newRange.selectNodeContents(inputArea);
            newRange.collapse(false);
            selection.removeAllRanges();
            selection.addRange(newRange);
        };

        // --- Autocomplete ---
        function updateAutocompletePopup() {
            if (!autocompleteState.active || autocompleteState.suggestions.length === 0) {
                autocompletePopup.classList.add('hidden');
                return;
            }
            autocompletePopup.innerHTML = autocompleteState.suggestions.map((s, i) =>
                `<div class="autocomplete-item ${i === autocompleteState.selectedIndex ? 'selected' : ''}" data-index="${i}">${s}</div>`
            ).join('');

            const range = window.getSelection().getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const inputRect = inputArea.getBoundingClientRect();
            autocompletePopup.style.left = `${rect.left - inputRect.left}px`;
            autocompletePopup.style.top = `${rect.bottom - inputRect.top + 5}px`;
            autocompletePopup.classList.remove('hidden');
        }

        function closeAutocomplete() { autocompleteState.active = false; autocompletePopup.classList.add('hidden'); }
        
        function handleAutocomplete() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return closeAutocomplete();

            const range = selection.getRangeAt(0);
            const textBeforeCursor = range.startContainer.textContent.substring(0, range.startOffset);
            
            if (/\W$/.test(textBeforeCursor) || textBeforeCursor.length === 0) {
                return closeAutocomplete();
            }

            const wordMatch = textBeforeCursor.match(/(\w+)$/);
            if (!wordMatch) return closeAutocomplete();

            const currentWord = wordMatch[1];
            autocompleteState.wordStartIndex = textBeforeCursor.length - currentWord.length;
            const suggestions = getAutocompleteKeywords(inputArea.textContent)
                .filter(kw => kw.startsWith(currentWord) && kw !== currentWord);

            if (suggestions.length > 0) {
                autocompleteState.active = true;
                autocompleteState.suggestions = suggestions;
                autocompleteState.selectedIndex = 0;
            } else { closeAutocomplete(); }
            updateAutocompletePopup();
        }

        function acceptSuggestion(suggestion) {
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const node = range.startContainer;

            const textBefore = node.textContent.substring(0, autocompleteState.wordStartIndex);
            const textAfter = node.textContent.substring(range.startOffset);
            node.textContent = `${textBefore}${suggestion} ${textAfter}`;
            
            range.setStart(node, (textBefore + suggestion + ' ').length);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            closeAutocomplete();
            inputArea.dispatchEvent(new Event('input', { bubbles: true }));
        }
        
        // --- Event Listeners ---
        inputArea.addEventListener('keydown', (event) => {
            if (autocompleteState.active) {
                if (['ArrowDown', 'ArrowUp', 'Escape', 'Enter', 'Tab'].includes(event.key)) {
                    event.preventDefault();
                    if (event.key === 'ArrowDown') {
                        autocompleteState.selectedIndex = (autocompleteState.selectedIndex + 1) % autocompleteState.suggestions.length;
                        updateAutocompletePopup();
                    } else if (event.key === 'ArrowUp') {
                        autocompleteState.selectedIndex = (autocompleteState.selectedIndex - 1 + autocompleteState.suggestions.length) % autocompleteState.suggestions.length;
                        updateAutocompletePopup();
                    } else if (event.key === 'Escape') {
                        closeAutocomplete();
                    } else if (event.key === 'Enter' || event.key === 'Tab') {
                        acceptSuggestion(autocompleteState.suggestions[autocompleteState.selectedIndex]);
                    }
                    return;
                }
            }
            
            if (event.key === 'Enter') {
                event.preventDefault();
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                range.deleteContents();
                
                const newlineNode = document.createTextNode('\n');
                range.insertNode(newlineNode);
                
                range.setStartAfter(newlineNode);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                
                inputArea.dispatchEvent(new Event('input', { bubbles: true }));
            }
        });

        inputArea.addEventListener('input', () => {
            processInput();
            handleAutocomplete();
        });
        
        roundingToggle.addEventListener('change', processInput);
        
        document.addEventListener('click', (e) => !autocompletePopup.contains(e.target) && closeAutocomplete());
        autocompletePopup.addEventListener('click', (e) => e.target.closest('.autocomplete-item') && acceptSuggestion(autocompleteState.suggestions[parseInt(e.target.dataset.index)]));
        eraseButton.addEventListener('click', () => { inputArea.textContent = ''; processInput(); showMessage('Calculator cleared!'); });

        $$('#save-buttons button').forEach((button, index) => button.addEventListener('click', () => {
            const key = `instacalc_slot_${index + 1}`;
            if (localStorage.getItem(key)) {
                confirmModal.classList.add('flex'); confirmModal.classList.remove('hidden');
                $('#confirm-ok').onclick = () => { localStorage.setItem(key, inputArea.textContent); confirmModal.classList.add('hidden'); showMessage(`Saved to slot ${index + 1}!`); };
                $('#confirm-cancel').onclick = () => confirmModal.classList.add('hidden');
            } else { localStorage.setItem(key, inputArea.textContent); showMessage(`Saved to slot ${index + 1}!`); }
        }));
        $$('#load-buttons button').forEach((button, index) => button.addEventListener('click', () => {
            const savedValue = localStorage.getItem(`instacalc_slot_${index + 1}`);
            if (savedValue) { inputArea.textContent = savedValue; processInput(); showMessage(`Loaded from slot ${index + 1}!`); }
            else { showMessage(`Slot ${index + 1} is empty.`); }
        }));
        
        noSleepToggle.addEventListener('change', async (e) => {
            if (e.target.checked) {
                if ('wakeLock' in navigator) {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        wakeLock.addEventListener('release', () => { if(e.target.checked) { e.target.checked = false; showMessage('Wake lock released.'); }});
                        showMessage('Screen wake lock active.');
                    } catch (err) { showMessage(`Error: ${err.message}`); e.target.checked = false; }
                } else { showMessage('Wake Lock API not supported.'); e.target.checked = false; }
            } else if (wakeLock) { wakeLock.release(); wakeLock = null; }
        });
        
        window.addEventListener('DOMContentLoaded', () => {
            inputArea.textContent = `// UI is now perfectly aligned!
total = 700
total`;
            processInput();
        });

    </script>
</body>
</html>
